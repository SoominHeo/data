So, people argue vigorously about the definition of life.

I will say that life involves computation.

So this is a computer program.

Booted up in a cell, the program would execute, and it could result in this person; or with a small change, it could result in this person; or another small change, this person; or with a larger change, this dog, or this tree, or this whale. 

So now, if you take this metaphor [of] genome as program seriously, you have to consider that Chris Anderson is a computer-fabricated artifact, as is Jim Watson, Craig Venter, as are all of us.

And in convincing yourself that this metaphor is true, there are lots of similarities between genetic programs and computer programs that could help to convince you.

A small mutation can take a two-wing fly and make it a four-wing fly.

Or it could take a fly and put legs where its antennae should be.

Or if you're familiar with "The Princess Bride," it could create a six-fingered man. 

Now, a hallmark of computer programs is just this kind of sensitivity to small changes.

If your bank account's one dollar, and you flip a single bit, you could end up with a thousand dollars.

So these small changes are things that I think that -- they indicate to us that a complicated computation in development is underlying these amplified, large changes. 

So now, all of this indicates that there are molecular programs underlying biology, and it shows the power of molecular programs -- biology does.

And what I want to do is write molecular programs, potentially to build technology.

They're cell-oriented.

So my friends, molecular programmers, and I have a sort of biomolecule-centric approach.

So, these are all the machines in a cell.

There's a camera.

My little group of molecular programmers are trying to refashion all of these parts from DNA.

We're not DNA zealots, but DNA is the cheapest, easiest to understand and easy to program material to do this.

And as other things become easier to use -- maybe protein -- we'll work with those. 

If we succeed, what will molecular programming look like?

And what happens if you water and feed that seed appropriately, is it will do a developmental computation, a molecular computation, and it'll build an electronic computer.

There are other questions like this, too.

One of them is Craig Venter's question.

(Laughter) And just as he's writing, you know, bacteria that will be smaller, he's writing genomes that will work, we could write smaller programs that would do what Microsoft Word does. 

Now, these are big questions in computer science.

Almost -- many of them are impossible.

But for some tasks, we can start to answer them.

It's double-stranded, it's a double helix, has the As, Ts, Cs and Gs that pair to hold the strands together.

But a lot of their approaches, though elegant, take a long time.

They can take a couple of years, or it can be difficult to design. 

And here's how we do it. 

The net action of many of these on that long strand is to fold it into something like a rectangle. 

And what happens is that we mix these strands together.

We heat them up, we add a little bit of salt, we heat them up to almost boiling and cool them down, and as we cool them down, the short strands bind the long strands and start to form structure.

And you can see a little bit of double helix forming there.

I wanted to fold DNA into something that goes up over the eye, down the nose, up the nose, around the forehead, back down and end in a little loop like this.

And so, I thought, if this could work, anything could work.

So I had the computer program design the short staples to do this.

I ordered them; they came by FedEx.

I mixed them up, heated them, cooled them down, and I got 50 billion little smiley faces floating around in a single drop of water.

And each one of these is just one-thousandth the width of a human hair, OK? 

So, they're all floating around in solution, and to look at them, you have to get them on a surface where they stick.

So, you pour them out onto a surface and they start to stick to that surface, and we take a picture using an atomic-force microscope.

It's got a needle, like a record needle, that goes back and forth over the surface, bumps up and down, and feels the height of the first surface.

It feels the DNA origami.

There's the atomic-force microscope working and you can see that the landing's a little rough.

When you zoom in, they've got, you know, weak jaws that flip over their heads and some of their noses get punched out, but it's pretty good.

Now, what's great about this is anybody can do this.

It's China, right?

(Laughter) So, this works really well and you can make patterns as well as shapes, OK?

And you can make a map of the Americas and spell DNA with DNA. 

And what's really neat about it -- well, actually, this all looks like nano-artwork, but it turns out that nano-artwork is just what you need to make nano-circuits.

So, you can put circuit components on the staples, like a light bulb and a light switch.

Let the thing assemble, and you'll get some kind of a circuit.

And then you can maybe wash the DNA away and have the circuit left over.

So, this is what some colleagues of mine at Caltech did.

They took a DNA origami, organized some carbon nano-tubes, made a little switch, you see here, wired it up, tested it and showed that it is indeed a switch.

So it's very promising for making small computers. 

Now, I want to get back to that compiler.

The DNA origami is a proof that that compiler actually works.

You can compile it to molecules, send it to a synthesizer, and it actually works.

You have your molecular compiler, you can do whatever you want.

The fact is that it does not scale.

So if you want to build a human from DNA origami, the problem is, you need a long strand that's 10 trillion trillion bases long.

That's three light years' worth of DNA, so we're not going to do this.

We're going to turn to another technology, called algorithmic self-assembly of tiles.

You zoom in, there are just four DNA strands and they have little single-stranded bits on them that can bind to other tiles, if they match.

And we like to draw these tiles as little squares.

And if you look at their sticky ends, these little DNA bits, you can see that they actually form a checkerboard pattern.

So, these tiles would make a complicated, self-assembling checkerboard.

And the point of this, if you didn't catch that, is that tiles are a kind of molecular program and they can output patterns.

So, you can come up with a set of tiles that when they come together, form a little binary counter rather than a checkerboard.

So you can read off binary numbers five, six and seven. 

You can encode the number 32 in the right-hand side of a DNA origami, and when you add those tiles that count, they will start to count -- they will read that 32 and they'll stop at 32.

It knows when to stop growing because it can count.

It knows how big it is.

So, that answers that sort of first question I was talking about.

It doesn't tell us how babies do it, however. 

So now, we can use this counting to try and get at much bigger things than DNA origami could otherwise.

The counter serves as a template to fill in a square in the middle of this thing.

And the neat thing about it is, is that it's also reprogrammable.

You can just change a couple of the DNA strands in this binary representation and you'll get 96 rather than 32.

And if you do that, the origami's the same size, but the resulting square that you get is three times bigger. 

So, this sort of recapitulates what I was telling you about development.

You have a very sensitive computer program where small changes -- single, tiny, little mutations -- can take something that made one size square and make something very much bigger.

Now, this -- using counting to compute and build these kinds of things by this kind of developmental process is something that also has bearing on Craig Venter's question.

If we wanted to make a square of size 10, 100 or 1,000, if we used DNA origami alone, we would require a number of DNA strands that's the square of the size of that square; so we'd need 100, 10,000 or a million DNA strands.

That's really not affordable.

But if we use a little computation -- we use origami, plus some tiles that count -- then we can get away with using 100, 200 or 300 DNA strands.

And so we can exponentially reduce the number of DNA strands we use, if we use counting, if we use a little bit of computation.

And finally, I'm going to get back to that sort of crazy idea about computers building computers.

If you look at the square that you build with the origami and some counters growing off it, the pattern that it has is exactly the pattern that you need to make a memory.

So you can actually make a complicated circuit using a little bit of computation.

And you can see how they count.

(Laughter) 

So, it turns out we actually had this idea nine years ago, and that's about the time constant for how long it takes to do these kinds of things, so I think we made a lot of progress.

We've got ideas about how to fix these errors.

And I think in the next five or 10 years, we'll make the kind of squares that I described and maybe even get to some of those self-assembled circuits. 

So now, what do I want you to take away from this talk?

You know, so this is all very cool, but what I'd like you to take from the talk, hopefully from some of those big questions, is that this molecular programming isn't just about making gadgets.

It's not just making about -- it's making self-assembled cell phones and circuits.

